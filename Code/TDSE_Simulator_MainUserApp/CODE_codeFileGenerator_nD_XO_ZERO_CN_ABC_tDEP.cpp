#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

using namespace std;

int main(int argNum, char **argVec){
    if (argNum<14){
        cout << "Error while reading the arguments. Too few arguments introduced? \n";
        return -1;
    }
    ofstream writtenFile;
    int option;
    sscanf(argVec[10], "%d", &option);
    
    if(option==5){ //XO NOT PARALLEL
        
    writtenFile.open("CODE_simulator_nD_XO_ZERO_CN_ABC_tDEP.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }

    writtenFile <<"//SCHRODINGER EQUATION SOLVER nD - XO ALGORITHM ZERO-th ORDER APROXIMATION of G, J:\n// Each single particle SE is solved with the CRANCK NICOLSON METHOD using Absorbing Boundary Conditions (ABCs)\n// SUPPORTS TIME DEPENDENT POTENTIALS\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <cmath>\n#include <random>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\nconst double PI = 3.141592653589793238463;\n const double EULER=2.718281828459045;\n// We DEFINE the INITIAL WAVEPACKET\ncdouble psi0(double *q){\n" << argVec[2] <<";\n}\n//We define the Potential Energy Field in time\ndouble V(double* q, double t){\n" << argVec[3] <<";\n}\n//MAIN----------------------------------------------------------------\nint main(){\n//STUFF DECLARATION--------------------------------------------------------------------\nint dimNum = "<< argVec[1] <<";\nint numTrajs=" << argVec[11] <<";\ndouble* qAux=new double[dimNum];\ndouble hbar =" << argVec[13] <<";\ndouble m[] ={" << argVec[4] <<"};\n//We define the spatial grid\nint qDivs[] ={" << argVec[5]<< "};\ndouble qmin[] ={"<<argVec[6]<<"};\ndouble qmax[] ={"<<argVec[7]<<"};\ndouble* dq=new double[dimNum];\nfor(int i=0; i<dimNum; ++i) {dq[i]=(qmax[i]-qmin[i])/qDivs[i];}\n// We define the time grid\ndouble tmin=0.0;\ndouble dt="<< argVec[8]<<";\nint numIt="<< argVec[9] <<";\n//we define the trajectory matrix\ndouble** traj=new double*[numIt+1];\nfor (int i=0; i<=numIt; ++i){ traj[i]= new double[dimNum];} // the trajectory is saved in an array of numIt arrays of dimNum doubles\n// each of the numIt arrays contains the value for the trajectory in each of the coordinates at that iteration\n//We declare the array of n initial SPCWF, the auxiliar U2*psi vectors and the Conditional phase and velocityField vectors\nVectorXcd** psiNext = new VectorXcd*[dimNum];\nVectorXcd** conjPsi = new VectorXcd*[dimNum];\nVectorXcd** auxComplexVector = new VectorXcd*[dimNum]; //each entry points to a full SPCW\nVectorXcd** U2psi= new VectorXcd*[dimNum];\nArrayXd** velocityField = new ArrayXd*[dimNum];\nArrayXd** probDensity = new ArrayXd*[dimNum];\n//We declare the auxiliar position vectors for obtaining pondered initial positions form the multidimensional WF\nint gridPointsIfNotCond=1;\nfor(int i=0; i<dimNum; ++i){\ngridPointsIfNotCond*=(qDivs[i]+1);\n}\ndouble** positArrays=new double*[gridPointsIfNotCond];\nstd::function<void(int,long int*, double*)> recursiveFillPosit;\nrecursiveFillPosit = [&](int k, long int* s, double* qAux){\nif(k==0){\nfor(int i=0; i<=qDivs[0]; ++i){\nqAux[0] = qmin[0] + i*dq[0];\npositArrays[*s]=new double[dimNum];\nmemcpy ( positArrays[*s], qAux, sizeof(double)*dimNum );\n(*s)+=1;\n}\n}else{\nfor(int i=0; i<=qDivs[k]; ++i){\nqAux[k] = qmin[k] + i*dq[k];\nrecursiveFillPosit(k-1, s, qAux);\n}\n}\n};\nlong int s=0;\nrecursiveFillPosit(dimNum-1, &s, qAux);\ndouble* probabDensity= new double[gridPointsIfNotCond];\nstd::function<void(int,long int*, double*, cdouble (*psi0)(double*))> recursiveGenerateMultidimProbab;\nrecursiveGenerateMultidimProbab = [&](int k, long int*s, double* qAux, cdouble (*psi0)(double*)){\nif(k==0){\nfor(int i=0; i<=qDivs[0]; ++i){\nqAux[0] = qmin[0] + i*dq[0];\nprobabDensity[*s]=norm(psi0(qAux));\n(*s)+=1;\n}\n}else{\nfor(int i=0; i<=qDivs[k]; ++i){\nqAux[k] = qmin[k] + i*dq[k];\nrecursiveGenerateMultidimProbab(k-1, s, qAux, psi0);\n}\n}\n};\ns=0;\nrecursiveGenerateMultidimProbab(dimNum-1, &s, qAux, psi0);\n// thus we have that probabDensity in each index contains the proability associated to the space point\n// registered in the same index but in the array positArrays (as a point in R^n)\n//now we build the random number generator according to this distribution\nstd::default_random_engine generator;\nstd::discrete_distribution<int> distribution (probabDensity,probabDensity+gridPointsIfNotCond-1);\nint randomIndex;\n// We build the templates for two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble>** U1= new SparseMatrix<cdouble>*[dimNum]; // one operator per considered dimension\nSparseMatrix<cdouble>** U2= new SparseMatrix<cdouble>*[dimNum]; // one operator per considered dimension\ncdouble a;\nSparseLU<SparseMatrix<cdouble>> LUsolver;\n//we build the paramters for the ABCs\ndouble* s1 = new double[dimNum];\ndouble* s2 = new double[dimNum];\ndouble* r1 = new double[dimNum];\ndouble* r2 = new double[dimNum];\n//parameters for trajectory evolution and phase continousiçation\ndouble whole, fractional;\n//we declare and build the basis of the operators and the vectors to use\nfor(int i=0; i<dimNum; ++i){\npsiNext[i]= new VectorXcd(qDivs[i]+1);\nconjPsi[i]= new VectorXcd(qDivs[i]+1);\nauxComplexVector[i]= new VectorXcd(qDivs[i]+1);\nprobDensity[i]= new ArrayXd(qDivs[i]+1);\nU2psi[i]= new VectorXcd(qDivs[i]+1);\nvelocityField[i] = new ArrayXd(qDivs[i]+1);\n\nU1[i] = new SparseMatrix<cdouble>(qDivs[i]+1, qDivs[i]+1);\nU1[i]->reserve(VectorXi::Constant(qDivs[i]+1,3));\nU2[i] = new SparseMatrix<cdouble>(qDivs[i]+1, qDivs[i]+1);\nU2[i]->reserve(VectorXi::Constant(qDivs[i]+1,3));\na=J*dt*hbar/(4*m[i]*dq[i]*dq[i]);\nfor(int j=1;j<qDivs[i];++j){\nU1[i]->insert(j,j+1)= -a;\nU1[i]->insert(j,j-1)= -a;\nU1[i]->insert(j,j)= 1.0+J*1.0;\n}\nU1[i]->insert(0,0)= J*1.0;\nU1[i]->insert(qDivs[i],qDivs[i])= J*1.0;\nU1[i]->insert(0,1)= J*1.0;\nU1[i]->insert(qDivs[i],qDivs[i]-1)= J*1.0;\nU1[i]->makeCompressed();\n*U2[i] = U1[i]->conjugate();\nU2[i]->makeCompressed();\n}\n//output files prepared\nofstream psiDataFile, trajDataFile;\npsiDataFile.open(\"DATA_rawSimulationData_nD_XO_ZERO_CN_ABC_tDEP.txt\");\ntrajDataFile.open(\"DATA_trajectoriesToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\npsiDataFile << std::setprecision(17);\ntrajDataFile << std::setprecision(17);\npsiDataFile << dimNum << \" \" << numIt << \" \";\nfor(int dim=0; dim< dimNum; ++dim){ psiDataFile << qDivs[dim] << \" \";} for(int dim=0; dim< dimNum; ++dim){ psiDataFile << qmin[dim] << \" \";}\nfor(int dim=0; dim< dimNum; ++dim){ psiDataFile << qmax[dim] << \" \";}\npsiDataFile<< \" (dimensionNumber, time iterations, SpatialDivisions in each dimension, qmin in each dimension, qmax in each dimension) XO ZERO CN ABCs \" << endl;\n//BEGINING OF THE PROPER ALGORITHM-------------------------------------------------------------------\n// everything is iterated as many times as trajectories we want to evolve using the algorithm\nfor(int trajNum=0; trajNum<numTrajs; ++trajNum){\n//we choose the initial coordinates of the trajectory of this iteration randomly pondered according to the initial WF\nrandomIndex=distribution(generator);\nfor(int i=0; i<dimNum; i++){\ntraj[0][i] = positArrays[randomIndex][i];\n}\nfor(int i=0; i<dimNum; ++i){ // coordinate number\nfor(int j=0; j<dimNum; ++j){ qAux[j]=traj[0][j];} //evaluation of the qb[t0]\nfor(int j=0; j<=qDivs[i]; ++j){\nqAux[i]=qmin[i]+j*dq[i];\n// We build the the n initial SPCWFs - Single Particle Conditional Wave Functions\n(*psiNext[i])(j)=psi0(qAux);\n}\n//for implementing the ABC-s\ns1[i] = hbar*2.0/m[i]; //we define the group velocities to be absorbed in the ABCs were q=hbar*k/m !!!!!SET IT 2*K0 if u want absorbing with k0>0 and SET it -2*k0 if k0<0\ns2[i] = s1[i]; // then the wavenumer k0 will be absorbed to second order\nr1[i] = 2.0/(s1[i]+s2[i]); //parameters to make it easier the boundary implementation of U1 and U2 matrixes\nr2[i] = s1[i]*s2[i]/(2*(s1[i]+s2[i]));\n}\n//TIME ITERATIONS--------------------------------------------------\nfor(int it=0; it<numIt; ++it){\nfor(int dim=0; dim<dimNum; ++dim){\nfor(int j=0; j<dimNum; ++j){ qAux[j]=traj[it][j];} //REVISAR IT A BER HOLAN BADAN!!!!! //evaluation of the b\n//we redefine the propagator matrices for the new time (the potential is time dependent)\nfor(int i=1;i<qDivs[dim];++i){\nqAux[dim]=qmin[dim]+i*dq[dim];\nU1[dim]->coeffRef(i,i)= 1.0+J*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\n}\nU1[dim]->coeffRef(0,0)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(0,1)= J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(qDivs[dim],qDivs[dim])= -J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(qDivs[dim],qDivs[dim]-1)= J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->makeCompressed();\n*U2[dim] = U1[dim]->conjugate();\nU2[dim]->coeffRef(0,0)= J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(0,1)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(qDivs[dim],qDivs[dim])= J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(qDivs[dim],qDivs[dim]-1)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->makeCompressed();\nLUsolver.compute(*U1[dim]);\nif(LUsolver.info()!=Success) {cout << \"LU decomposition FAILED!\" << endl << LUsolver.lastErrorMessage()<<endl<<endl;goto EndTrajComput; }\n*U2psi[dim]= (*U2[dim])*(*psiNext[dim]);\n*psiNext[dim] = LUsolver.solve(*U2psi[dim]);\n} //End evolving a time unit the SPCWFs\n//COMPUTE NEXT TRAJS--------------------------------------------------------------------------------------\n// we extract the conditional phase of each of the SPCWF, make it a continous curve and obtain the conditional velocity field\nfor(int dim=0; dim<dimNum; ++dim){\n//Get the probability density function and the inverse psi\n*probDensity[dim] = abs2(psiNext[dim]->array());\n(*conjPsi[dim]) = conj(psiNext[dim]->array());\n// psi_qi^-1* diff(psi_qi,qi) is computed\n//the borders are get with an Euler difference o(dq) and the immediate divisions with a central difference o(dq^2)\n(*auxComplexVector[dim])(0)=(*conjPsi[dim])(0)*((*psiNext[dim])(1)-(*psiNext[dim])(0))/(dq[dim]*(*probDensity[dim])(0));\n(*auxComplexVector[dim])(1)=(*conjPsi[dim])(1)*((*psiNext[dim])(2)-(*psiNext[dim])(0))/(2.0*dq[dim]*(*probDensity[dim])(1));\n//the rest of points are got with a o(dq^4) difference\nfor(int i=2; i<(qDivs[dim]-2); i++){\n(*auxComplexVector[dim])(i)=(*conjPsi[dim])(i)*(-(*psiNext[dim])(i+2)+8.0*(*psiNext[dim])(i+1)-8.0*(*psiNext[dim])(i-1)+(*psiNext[dim])(i-2))/(12.0*dq[dim]*(*probDensity[dim])(i));\n}\n(*auxComplexVector[dim])(qDivs[dim]-1)=(*conjPsi[dim])(qDivs[dim]-1)*((*psiNext[dim])(qDivs[dim])-(*psiNext[dim])(qDivs[dim]-2))/(2.0*dq[dim]*(*probDensity[dim])(qDivs[dim]-1));\n(*auxComplexVector[dim])(qDivs[dim])=(*conjPsi[dim])(qDivs[dim])*((*psiNext[dim])(qDivs[dim])-(*psiNext[dim])(qDivs[dim]-1))/(dq[dim]*(*probDensity[dim])(qDivs[dim]));\n// imaginary part is extracted and Jk obtained\n*velocityField[dim] = (hbar/m[dim])*imag(auxComplexVector[dim]->array());\n// the next time of the trajectories is computed\n//we apply the discretisation of the grid to the traj positions\n//traj[it+1][dim] = traj[it][dim]+(*velocityField[dim])( round((traj[it][dim]-qmin[dim])/dq[dim]) )*dt;\nfractional = std::modf((traj[it][dim]-qmin[dim])/dq[dim], &whole);\nif(whole>=qDivs[dim]){whole=qDivs[dim]-2;}else if(whole<0){whole=0;}\ntraj[it+1][dim] = traj[it][dim]+( (1-fractional)*(*velocityField[dim])(whole)+fractional*(*velocityField[dim])(whole+1) )*dt;\n}/*\nfor(int dim=0; dim<dimNum; ++dim){\n psiDataFile << *psiNext[dim] << endl << endl;\n}\npsiDataFile << endl;*/\n//Output al file aki todas psi de una\n}//go to next time iteration\nEndTrajComput:\nfor(int it=0; it<=numIt; ++it){\nfor(int dim =0; dim<dimNum; ++dim){ trajDataFile << traj[it][dim] << \" \";\n}\ntrajDataFile <<\"0\" <<endl;\n}\ntrajDataFile << endl; }\npsiDataFile.close();\ntrajDataFile.close();\nreturn 0;\n}\n";
    
    writtenFile.close();
    return 0;
    }else if(option==7){ //XO NOT PARALLEL ANIMATION NO TENSOR PRODUCT
        
    writtenFile.open("CODE_simulator_nD_XO_ZERO_CN_ABC_tDEP.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }
    writtenFile << "//SCHRODINGER EQUATION SOLVER nD - XO ALGORITHM ZERO-th ORDER APROXIMATION of G, J:\n// Each single particle SE is solved with the CRANCK NICOLSON METHOD using Absorbing Boundary Conditions (ABCs)\n// SUPPORTS TIME DEPENDENT POTENTIALS\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <cmath>\n#include <random>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\nconst double PI = 3.141592653589793238463;\nconst double EULER=2.718281828459045;\n// We DEFINE the INITIAL WAVEPACKET\ncdouble psi0(double *q){\n" << argVec[2] <<";\n}\n//We define the Potential Energy Field in time\ndouble V(double* q, double t){\n" << argVec[3] <<";\n}\n//MAIN----------------------------------------------------------------\nint main(){\n//STUFF DECLARATION--------------------------------------------------------------------\nint dimNum = "<< argVec[1] <<";\nint numTrajs=" << argVec[11] <<";\ndouble* qAux=new double[dimNum];\ndouble hbar =" << argVec[13] <<";\ndouble m[] ={" << argVec[4] <<"};\n//We define the spatial grid\nint qDivs[] ={" << argVec[5]<< "};\ndouble qmin[] ={"<<argVec[6]<<"};\ndouble qmax[] ={"<<argVec[7]<<"};\ndouble* dq=new double[dimNum];\nfor(int i=0; i<dimNum; ++i) {dq[i]=(qmax[i]-qmin[i])/qDivs[i];}\n// We define the time grid\ndouble tmin=0.0;\ndouble dt="<< argVec[8]<<";\nint numIt="<< argVec[9] <<";\n//we define the trajectory matrix\ndouble** traj=new double*[numIt+1];\nfor (int i=0; i<=numIt; ++i){ traj[i]= new double[dimNum];} // the trajectory is saved in an array of numIt arrays of dimNum doubles\n// each of the numIt arrays contains the value for the trajectory in each of the coordinates at that iteration\n//We declare the array of n initial SPCWF, the auxiliar U2*psi vectors and the Conditional phase and velocityField vectors\nVectorXcd** psiNext = new VectorXcd*[dimNum];\nVectorXcd** conjPsi = new VectorXcd*[dimNum];\nVectorXcd** auxComplexVector = new VectorXcd*[dimNum]; //each entry points to a full SPCW\nVectorXcd** U2psi= new VectorXcd*[dimNum];\nArrayXd** velocityField = new ArrayXd*[dimNum];\nArrayXd** probDensity = new ArrayXd*[dimNum];\n//We declare the auxiliar position vectors for obtaining pondered initial positions form the multidimensional WF\nint gridPointsIfNotCond=1;\nfor(int i=0; i<dimNum; ++i){\ngridPointsIfNotCond*=(qDivs[i]+1);\n}\ndouble** positArrays=new double*[gridPointsIfNotCond];\nstd::function<void(int,long int*, double*)> recursiveFillPosit;\nrecursiveFillPosit = [&](int k, long int* s, double* qAux){\nif(k==0){\nfor(int i=0; i<=qDivs[0]; ++i){\nqAux[0] = qmin[0] + i*dq[0];\npositArrays[*s]=new double[dimNum];\nmemcpy ( positArrays[*s], qAux, sizeof(double)*dimNum );\n(*s)+=1;\n}\n}else{\nfor(int i=0; i<=qDivs[k]; ++i){\nqAux[k] = qmin[k] + i*dq[k];\nrecursiveFillPosit(k-1, s, qAux);\n}\n}\n};\nlong int s=0;\nrecursiveFillPosit(dimNum-1, &s, qAux);\ndouble* probabDensity= new double[gridPointsIfNotCond];\nstd::function<void(int,long int*, double*, cdouble (*psi0)(double*))> recursiveGenerateMultidimProbab;\nrecursiveGenerateMultidimProbab = [&](int k, long int*s, double* qAux, cdouble (*psi0)(double*)){\nif(k==0){\nfor(int i=0; i<=qDivs[0]; ++i){\nqAux[0] = qmin[0] + i*dq[0];\nprobabDensity[*s]=norm(psi0(qAux));\n(*s)+=1;\n}\n}else{\nfor(int i=0; i<=qDivs[k]; ++i){\nqAux[k] = qmin[k] + i*dq[k];\nrecursiveGenerateMultidimProbab(k-1, s, qAux, psi0);\n}\n}\n};\ns=0;\nrecursiveGenerateMultidimProbab(dimNum-1, &s, qAux, psi0);\n// thus we have that probabDensity in each index contains the proability associated to the space point\n// registered in the same index but in the array positArrays (as a point in R^n)\n//now we build the random number generator according to this distribution\nstd::default_random_engine generator;\nstd::discrete_distribution<int> distribution (probabDensity,probabDensity+gridPointsIfNotCond-1);\nint randomIndex;\n// We build the templates for two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble>** U1= new SparseMatrix<cdouble>*[dimNum]; // one operator per considered dimension\nSparseMatrix<cdouble>** U2= new SparseMatrix<cdouble>*[dimNum]; // one operator per considered dimension\ncdouble a;\nSparseLU<SparseMatrix<cdouble>> LUsolver;\n//we build the paramters for the ABCs\ndouble* s1 = new double[dimNum];\ndouble* s2 = new double[dimNum];\ndouble* r1 = new double[dimNum];\ndouble* r2 = new double[dimNum];\n//parameters for trajectory evolution and phase continousiçation\ndouble whole, fractional;\n//we declare and build the basis of the operators and the vectors to use\nfor(int i=0; i<dimNum; ++i){\npsiNext[i]= new VectorXcd(qDivs[i]+1);\nconjPsi[i]= new VectorXcd(qDivs[i]+1);\nauxComplexVector[i]= new VectorXcd(qDivs[i]+1);\nprobDensity[i]= new ArrayXd(qDivs[i]+1);\nU2psi[i]= new VectorXcd(qDivs[i]+1);\nvelocityField[i] = new ArrayXd(qDivs[i]+1);\n\nU1[i] = new SparseMatrix<cdouble>(qDivs[i]+1, qDivs[i]+1);\nU1[i]->reserve(VectorXi::Constant(qDivs[i]+1,3));\nU2[i] = new SparseMatrix<cdouble>(qDivs[i]+1, qDivs[i]+1);\nU2[i]->reserve(VectorXi::Constant(qDivs[i]+1,3));\na=J*dt*hbar/(4*m[i]*dq[i]*dq[i]);\nfor(int j=1;j<qDivs[i];++j){\nU1[i]->insert(j,j+1)= -a;\nU1[i]->insert(j,j-1)= -a;\nU1[i]->insert(j,j)= 1.0+J*1.0;\n}\nU1[i]->insert(0,0)= J*1.0;\nU1[i]->insert(qDivs[i],qDivs[i])= J*1.0;\nU1[i]->insert(0,1)= J*1.0;\nU1[i]->insert(qDivs[i],qDivs[i]-1)= J*1.0;\nU1[i]->makeCompressed();\n*U2[i] = U1[i]->conjugate();\nU2[i]->makeCompressed();\n}\n//output files prepared\nofstream probabDataFile, trajDataFile;\n//psiDataFile.open(\"DATA_rawSimulationData_nD_XO_ZERO_CN_ABC_tDEP.txt\");\nprobabDataFile.open(\"DATA_probabilityToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\ntrajDataFile.open(\"DATA_trajectoriesToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\n//psiDataFile << std::setprecision(17);\nprobabDataFile << std::setprecision(17);\ntrajDataFile << std::setprecision(17);\n/*probabDataFile << dimNum << \" \" << numIt << \" \";\nfor(int dim=0; dim< dimNum; ++dim){ probabDataFile << qDivs[dim] << \" \";} for(int dim=0; dim< dimNum; ++dim){ probabDataFile << qmin[dim] << \" \";}\nfor(int dim=0; dim< dimNum; ++dim){ probabDataFile << qmax[dim] << \" \";}\nprobabDataFile<< \" (dimensionNumber, time iterations, SpatialDivisions in each dimension, qmin in each dimension, qmax in each dimension) XO ZERO CN ABCs \" << endl;*/\n//BEGINING OF THE PROPER ALGORITHM-------------------------------------------------------------------\n// everything is iterated as many times as trajectories we want to evolve using the algorithm\nfor(int trajNum=0; trajNum<numTrajs; ++trajNum){\n//we choose the initial coordinates of the trajectory of this iteration randomly pondered according to the initial WF\nrandomIndex=distribution(generator);\nfor(int i=0; i<dimNum; i++){\ntraj[0][i] = positArrays[randomIndex][i];\n}\nfor(int i=0; i<dimNum; ++i){ // coordinate number\nfor(int j=0; j<dimNum; ++j){ qAux[j]=traj[0][j];} //evaluation of the qb[t0]\nfor(int j=0; j<=qDivs[i]; ++j){\nqAux[i]=qmin[i]+j*dq[i];\n// We build the the n initial SPCWFs - Single Particle Conditional Wave Functions\n(*psiNext[i])(j)=psi0(qAux);\n}\n//for implementing the ABC-s\ns1[i] = hbar*2.0/m[i]; //we define the group velocities to be absorbed in the ABCs were q=hbar*k/m !!!!!SET IT 2*K0 if u want absorbing with k0>0 and SET it -2*k0 if k0<0\ns2[i] = s1[i]; // then the wavenumer k0 will be absorbed to second order\nr1[i] = 2.0/(s1[i]+s2[i]); //parameters to make it easier the boundary implementation of U1 and U2 matrixes\nr2[i] = s1[i]*s2[i]/(2*(s1[i]+s2[i]));\n}\n//TIME ITERATIONS--------------------------------------------------\nfor(int it=0; it<numIt; ++it){\nfor(int dim=0; dim<dimNum; ++dim){\nfor(int j=0; j<dimNum; ++j){ qAux[j]=traj[it][j];} //REVISAR IT A BER HOLAN BADAN!!!!! //evaluation of the b\n//we redefine the propagator matrices for the new time (the potential is time dependent)\nfor(int i=1;i<qDivs[dim];++i){\nqAux[dim]=qmin[dim]+i*dq[dim];\nU1[dim]->coeffRef(i,i)= 1.0+J*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\n}\nU1[dim]->coeffRef(0,0)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(0,1)= J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(qDivs[dim],qDivs[dim])= -J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(qDivs[dim],qDivs[dim]-1)= J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->makeCompressed();\n*U2[dim] = U1[dim]->conjugate();\nU2[dim]->coeffRef(0,0)= J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(0,1)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(qDivs[dim],qDivs[dim])= J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(qDivs[dim],qDivs[dim]-1)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->makeCompressed();\nLUsolver.compute(*U1[dim]);\nif(LUsolver.info()!=Success) {cout << \"LU decomposition FAILED!\" << endl << LUsolver.lastErrorMessage()<<endl<<endl;goto EndTrajComput; }\n*U2psi[dim]= (*U2[dim])*(*psiNext[dim]);\n*psiNext[dim] = LUsolver.solve(*U2psi[dim]);\n} //End evolving a time unit the SPCWFs\n//COMPUTE NEXT TRAJS--------------------------------------------------------------------------------------\n// we extract the conditional phase of each of the SPCWF, make it a continous curve and obtain the conditional velocity field\nfor(int dim=0; dim<dimNum; ++dim){\n//Get the probability density function and the inverse psi\n*probDensity[dim] = abs2(psiNext[dim]->array());\n(*conjPsi[dim]) = conj(psiNext[dim]->array());\n// psi_qi^-1* diff(psi_qi,qi) is computed\n//the borders are get with an Euler difference o(dq) and the immediate divisions with a central difference o(dq^2)\n(*auxComplexVector[dim])(0)=(*conjPsi[dim])(0)*((*psiNext[dim])(1)-(*psiNext[dim])(0))/(dq[dim]*(*probDensity[dim])(0));\n(*auxComplexVector[dim])(1)=(*conjPsi[dim])(1)*((*psiNext[dim])(2)-(*psiNext[dim])(0))/(2.0*dq[dim]*(*probDensity[dim])(1));\n//the rest of points are got with a o(dq^4) difference\nfor(int i=2; i<(qDivs[dim]-2); i++){\n(*auxComplexVector[dim])(i)=(*conjPsi[dim])(i)*(-(*psiNext[dim])(i+2)+8.0*(*psiNext[dim])(i+1)-8.0*(*psiNext[dim])(i-1)+(*psiNext[dim])(i-2))/(12.0*dq[dim]*(*probDensity[dim])(i));\n}\n(*auxComplexVector[dim])(qDivs[dim]-1)=(*conjPsi[dim])(qDivs[dim]-1)*((*psiNext[dim])(qDivs[dim])-(*psiNext[dim])(qDivs[dim]-2))/(2.0*dq[dim]*(*probDensity[dim])(qDivs[dim]-1));\n(*auxComplexVector[dim])(qDivs[dim])=(*conjPsi[dim])(qDivs[dim])*((*psiNext[dim])(qDivs[dim])-(*psiNext[dim])(qDivs[dim]-1))/(dq[dim]*(*probDensity[dim])(qDivs[dim]));\n// imaginary part is extracted and Jk obtained\n*velocityField[dim] = (hbar/m[dim])*imag(auxComplexVector[dim]->array());\n// the next time of the trajectories is computed\n//we apply the discretisation of the grid to the traj positions\n//traj[it+1][dim] = traj[it][dim]+(*velocityField[dim])( round((traj[it][dim]-qmin[dim])/dq[dim]) )*dt;\nfractional = std::modf((traj[it][dim]-qmin[dim])/dq[dim], &whole);\nif(whole>=qDivs[dim]){whole=qDivs[dim]-2;}else if(whole<0){whole=0;}\ntraj[it+1][dim] = traj[it][dim]+( (1-fractional)*(*velocityField[dim])(whole)+fractional*(*velocityField[dim])(whole+1) )*dt;\n}\nfor(int dim=0; dim<dimNum; ++dim){\nprobabDataFile << abs2(psiNext[dim]->array()) << endl << endl<<endl;\n}\n//Output al file aki todas psi de una\n}//go to next time iteration\nEndTrajComput:\nfor(int it=0; it<=numIt; ++it){\nfor(int dim =0; dim<dimNum; ++dim){ trajDataFile << traj[it][dim] << \" \";\n}\ntrajDataFile <<\" 0\"<<endl;\n}\n }\nprobabDataFile.close();\ntrajDataFile.close();if(dimNum==2){\nofstream potentialToPlot; \ncout << \" Proceeding to prepare the Potential Energy Plot data...\" << endl; potentialToPlot.open(\"DATA_potentialToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");int enoughStepq0=qDivs[0]*"<< argVec[12]<< ";int enoughStepq1=qDivs[1]*"<< argVec[12]<< ";for(int it=0; it<=numIt; ++it){for(int i=0; i<=qDivs[0]; i+=enoughStepq0){for(int j=0; j<=qDivs[1]; j+=enoughStepq1){qAux[0]=qmin[0]+i*dq[0]; qAux[1]=qmin[1]+j*dq[1];potentialToPlot << qAux[0] << \" \" << qAux[1] << \" \" << V(qAux, tmin+it*dt)<< endl;}potentialToPlot<<endl;}potentialToPlot<<endl;}potentialToPlot.close();}\nreturn 0;\n}\n";
    writtenFile.close();
    return 0;
    }else if(option==8){ //XO NOT PARALLEL ANIMATION YES TENSOR PRODUCT
        
    writtenFile.open("CODE_simulator_nD_XO_ZERO_CN_ABC_tDEP.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }
    writtenFile << "//SCHRODINGER EQUATION SOLVER nD - XO ALGORITHM ZERO-th ORDER APROXIMATION of G, J:\n// Each single particle SE is solved with the CRANCK NICOLSON METHOD using Absorbing Boundary Conditions (ABCs)\n// SUPPORTS TIME DEPENDENT POTENTIALS\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <cmath>\n#include <random>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\nconst double PI = 3.141592653589793238463;\nconst double EULER=2.718281828459045;\n// We DEFINE the INITIAL WAVEPACKET\ncdouble psi0(double *q){\n" << argVec[2] <<";\n}\n//We define the Potential Energy Field in time\ndouble V(double* q, double t){\n" << argVec[3] <<";\n}\n//MAIN----------------------------------------------------------------\nint main(){\n//STUFF DECLARATION--------------------------------------------------------------------\nint dimNum = "<< argVec[1] <<";\nint numTrajs=" << argVec[11] <<";\ndouble* qAux=new double[dimNum];\ndouble hbar =" << argVec[13] <<";\ndouble m[] ={" << argVec[4] <<"};\n//We define the spatial grid\nint qDivs[] ={" << argVec[5]<< "};\ndouble qmin[] ={"<<argVec[6]<<"};\ndouble qmax[] ={"<<argVec[7]<<"};\ndouble* dq=new double[dimNum];\nfor(int i=0; i<dimNum; ++i) {dq[i]=(qmax[i]-qmin[i])/qDivs[i];}\n// We define the time grid\ndouble tmin=0.0;\ndouble dt="<< argVec[8]<<";\nint numIt="<< argVec[9] <<";\n//we define the trajectory matrix\ndouble** traj=new double*[numIt+1];\nfor (int i=0; i<=numIt; ++i){ traj[i]= new double[dimNum];} // the trajectory is saved in an array of numIt arrays of dimNum doubles\n// each of the numIt arrays contains the value for the trajectory in each of the coordinates at that iteration\n//We declare the array of n initial SPCWF, the auxiliar U2*psi vectors and the Conditional phase and velocityField vectors\nVectorXcd** psiNext = new VectorXcd*[dimNum];\nVectorXcd** conjPsi = new VectorXcd*[dimNum];\nVectorXcd** auxComplexVector = new VectorXcd*[dimNum]; //each entry points to a full SPCW\nVectorXcd** U2psi= new VectorXcd*[dimNum];\nArrayXd** velocityField = new ArrayXd*[dimNum];\nArrayXd** probDensity = new ArrayXd*[dimNum];\n//We declare the auxiliar position vectors for obtaining pondered initial positions form the multidimensional WF\nint gridPointsIfNotCond=1;\nfor(int i=0; i<dimNum; ++i){\ngridPointsIfNotCond*=(qDivs[i]+1);\n}\ndouble** positArrays=new double*[gridPointsIfNotCond];\nstd::function<void(int,long int*, double*)> recursiveFillPosit;\nrecursiveFillPosit = [&](int k, long int* s, double* qAux){\nif(k==0){\nfor(int i=0; i<=qDivs[0]; ++i){\nqAux[0] = qmin[0] + i*dq[0];\npositArrays[*s]=new double[dimNum];\nmemcpy ( positArrays[*s], qAux, sizeof(double)*dimNum );\n(*s)+=1;\n}\n}else{\nfor(int i=0; i<=qDivs[k]; ++i){\nqAux[k] = qmin[k] + i*dq[k];\nrecursiveFillPosit(k-1, s, qAux);\n}\n}\n};\nlong int s=0;\nrecursiveFillPosit(dimNum-1, &s, qAux);\ndouble* probabDensity= new double[gridPointsIfNotCond];\nstd::function<void(int,long int*, double*, cdouble (*psi0)(double*))> recursiveGenerateMultidimProbab;\nrecursiveGenerateMultidimProbab = [&](int k, long int*s, double* qAux, cdouble (*psi0)(double*)){\nif(k==0){\nfor(int i=0; i<=qDivs[0]; ++i){\nqAux[0] = qmin[0] + i*dq[0];\nprobabDensity[*s]=norm(psi0(qAux));\n(*s)+=1;\n}\n}else{\nfor(int i=0; i<=qDivs[k]; ++i){\nqAux[k] = qmin[k] + i*dq[k];\nrecursiveGenerateMultidimProbab(k-1, s, qAux, psi0);\n}\n}\n};\ns=0;\nrecursiveGenerateMultidimProbab(dimNum-1, &s, qAux, psi0);\n// thus we have that probabDensity in each index contains the proability associated to the space point\n// registered in the same index but in the array positArrays (as a point in R^n)\n//now we build the random number generator according to this distribution\nstd::default_random_engine generator;\nstd::discrete_distribution<int> distribution (probabDensity,probabDensity+gridPointsIfNotCond-1);\nint randomIndex;\n// We build the templates for two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble>** U1= new SparseMatrix<cdouble>*[dimNum]; // one operator per considered dimension\nSparseMatrix<cdouble>** U2= new SparseMatrix<cdouble>*[dimNum]; // one operator per considered dimension\ncdouble a;\nSparseLU<SparseMatrix<cdouble>> LUsolver;\n//we build the paramters for the ABCs\ndouble* s1 = new double[dimNum];\ndouble* s2 = new double[dimNum];\ndouble* r1 = new double[dimNum];\ndouble* r2 = new double[dimNum];\n//parameters for trajectory evolution and phase continousiçation\ndouble whole, fractional;\n//A matrix to save the tensor product of the two SPCWF in the case of two dimensional systems and a position vector pair for an easier posterior plot\nMatrixXd tensorProduct(qDivs[1]+1, qDivs[0]+1);\nofstream tensorProdData;\ntensorProdData.open(\"DATA_tensorProduct_nD_XO_ZERO_CN_ABC_tDEP.txt\");\nint enoughStepq0=qDivs[0]*"<< argVec[12]<< ";\nint enoughStepq1=qDivs[1]*"<< argVec[12]<< ";\ndouble* posq0=new double[qDivs[0]+1];\ndouble* posq1=new double[qDivs[1]+1];\nfor(int i=0; i<=qDivs[0]; i+=enoughStepq0){\nposq0[i]=qmin[0]+i*dq[0];}for(int j=0; j<=qDivs[1]; j+=enoughStepq1){ posq1[j]=qmin[1]+j*dq[1];}\n//we declare and build the basis of the operators and the vectors to use\nfor(int i=0; i<dimNum; ++i){\npsiNext[i]= new VectorXcd(qDivs[i]+1);\nconjPsi[i]= new VectorXcd(qDivs[i]+1);\nauxComplexVector[i]= new VectorXcd(qDivs[i]+1);\nprobDensity[i]= new ArrayXd(qDivs[i]+1);\nU2psi[i]= new VectorXcd(qDivs[i]+1);\nvelocityField[i] = new ArrayXd(qDivs[i]+1);\n\nU1[i] = new SparseMatrix<cdouble>(qDivs[i]+1, qDivs[i]+1);\nU1[i]->reserve(VectorXi::Constant(qDivs[i]+1,3));\nU2[i] = new SparseMatrix<cdouble>(qDivs[i]+1, qDivs[i]+1);\nU2[i]->reserve(VectorXi::Constant(qDivs[i]+1,3));\na=J*dt*hbar/(4*m[i]*dq[i]*dq[i]);\nfor(int j=1;j<qDivs[i];++j){\nU1[i]->insert(j,j+1)= -a;\nU1[i]->insert(j,j-1)= -a;\nU1[i]->insert(j,j)= 1.0+J*1.0;\n}\nU1[i]->insert(0,0)= J*1.0;\nU1[i]->insert(qDivs[i],qDivs[i])= J*1.0;\nU1[i]->insert(0,1)= J*1.0;\nU1[i]->insert(qDivs[i],qDivs[i]-1)= J*1.0;\nU1[i]->makeCompressed();\n*U2[i] = U1[i]->conjugate();\nU2[i]->makeCompressed();\n}\n//output files prepared\nofstream probabDataFile, trajDataFile;\n//psiDataFile.open(\"DATA_rawSimulationData_nD_XO_ZERO_CN_ABC_tDEP.txt\");\nprobabDataFile.open(\"DATA_probabilityToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\ntrajDataFile.open(\"DATA_trajectoriesToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\n//psiDataFile << std::setprecision(17);\nprobabDataFile << std::setprecision(17);\ntrajDataFile << std::setprecision(17);\n/*probabDataFile << dimNum << \" \" << numIt << \" \";\nfor(int dim=0; dim< dimNum; ++dim){ probabDataFile << qDivs[dim] << \" \";} for(int dim=0; dim< dimNum; ++dim){ probabDataFile << qmin[dim] << \" \";}\nfor(int dim=0; dim< dimNum; ++dim){ probabDataFile << qmax[dim] << \" \";}\nprobabDataFile<< \" (dimensionNumber, time iterations, SpatialDivisions in each dimension, qmin in each dimension, qmax in each dimension) XO ZERO CN ABCs \" << endl;*/\n//BEGINING OF THE PROPER ALGORITHM-------------------------------------------------------------------\n// everything is iterated as many times as trajectories we want to evolve using the algorithm\nfor(int trajNum=0; trajNum<numTrajs; ++trajNum){\n//we choose the initial coordinates of the trajectory of this iteration randomly pondered according to the initial WF\nrandomIndex=distribution(generator);\nfor(int i=0; i<dimNum; i++){\ntraj[0][i] = positArrays[randomIndex][i];\n}\nfor(int i=0; i<dimNum; ++i){ // coordinate number\nfor(int j=0; j<dimNum; ++j){ qAux[j]=traj[0][j];} //evaluation of the qb[t0]\nfor(int j=0; j<=qDivs[i]; ++j){\nqAux[i]=qmin[i]+j*dq[i];\n// We build the the n initial SPCWFs - Single Particle Conditional Wave Functions\n(*psiNext[i])(j)=psi0(qAux);\n}\n//for implementing the ABC-s\ns1[i] = hbar*2.0/m[i]; //we define the group velocities to be absorbed in the ABCs were q=hbar*k/m !!!!!SET IT 2*K0 if u want absorbing with k0>0 and SET it -2*k0 if k0<0\ns2[i] = s1[i]; // then the wavenumer k0 will be absorbed to second order\nr1[i] = 2.0/(s1[i]+s2[i]); //parameters to make it easier the boundary implementation of U1 and U2 matrixes\nr2[i] = s1[i]*s2[i]/(2*(s1[i]+s2[i]));\n}\n//TIME ITERATIONS--------------------------------------------------\nfor(int it=0; it<numIt; ++it){\nfor(int dim=0; dim<dimNum; ++dim){\nfor(int j=0; j<dimNum; ++j){ qAux[j]=traj[it][j];} //REVISAR IT A BER HOLAN BADAN!!!!! //evaluation of the b\n//we redefine the propagator matrices for the new time (the potential is time dependent)\nfor(int i=1;i<qDivs[dim];++i){\nqAux[dim]=qmin[dim]+i*dq[dim];\nU1[dim]->coeffRef(i,i)= 1.0+J*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\n}\nU1[dim]->coeffRef(0,0)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(0,1)= J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(qDivs[dim],qDivs[dim])= -J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->coeffRef(qDivs[dim],qDivs[dim]-1)= J/(2*dq[dim])-J*r1[dim]/(2*dt)+(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU1[dim]->makeCompressed();\n*U2[dim] = U1[dim]->conjugate();\nU2[dim]->coeffRef(0,0)= J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(0,1)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(qDivs[dim],qDivs[dim])= J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->coeffRef(qDivs[dim],qDivs[dim]-1)= -J/(2*dq[dim])-J*r1[dim]/(2*dt)-(r1[dim]*V(qmin,tmin+dt*it)-r2[dim])/4.0;\nU2[dim]->makeCompressed();\nLUsolver.compute(*U1[dim]);\nif(LUsolver.info()!=Success) {cout << \"LU decomposition FAILED!\" << endl << LUsolver.lastErrorMessage()<<endl<<endl;goto EndTrajComput; }\n*U2psi[dim]= (*U2[dim])*(*psiNext[dim]);\n*psiNext[dim] = LUsolver.solve(*U2psi[dim]);\n} //End evolving a time unit the SPCWFs\n//COMPUTE NEXT TRAJS--------------------------------------------------------------------------------------\n// we extract the conditional phase of each of the SPCWF, make it a continous curve and obtain the conditional velocity field\nfor(int dim=0; dim<dimNum; ++dim){\n//Get the probability density function and the inverse psi\n*probDensity[dim] = abs2(psiNext[dim]->array());\n(*conjPsi[dim]) = conj(psiNext[dim]->array());\n// psi_qi^-1* diff(psi_qi,qi) is computed\n//the borders are get with an Euler difference o(dq) and the immediate divisions with a central difference o(dq^2)\n(*auxComplexVector[dim])(0)=(*conjPsi[dim])(0)*((*psiNext[dim])(1)-(*psiNext[dim])(0))/(dq[dim]*(*probDensity[dim])(0));\n(*auxComplexVector[dim])(1)=(*conjPsi[dim])(1)*((*psiNext[dim])(2)-(*psiNext[dim])(0))/(2.0*dq[dim]*(*probDensity[dim])(1));\n//the rest of points are got with a o(dq^4) difference\nfor(int i=2; i<(qDivs[dim]-2); i++){\n(*auxComplexVector[dim])(i)=(*conjPsi[dim])(i)*(-(*psiNext[dim])(i+2)+8.0*(*psiNext[dim])(i+1)-8.0*(*psiNext[dim])(i-1)+(*psiNext[dim])(i-2))/(12.0*dq[dim]*(*probDensity[dim])(i));\n}\n(*auxComplexVector[dim])(qDivs[dim]-1)=(*conjPsi[dim])(qDivs[dim]-1)*((*psiNext[dim])(qDivs[dim])-(*psiNext[dim])(qDivs[dim]-2))/(2.0*dq[dim]*(*probDensity[dim])(qDivs[dim]-1));\n(*auxComplexVector[dim])(qDivs[dim])=(*conjPsi[dim])(qDivs[dim])*((*psiNext[dim])(qDivs[dim])-(*psiNext[dim])(qDivs[dim]-1))/(dq[dim]*(*probDensity[dim])(qDivs[dim]));\n// imaginary part is extracted and Jk obtained\n*velocityField[dim] = (hbar/m[dim])*imag(auxComplexVector[dim]->array());\n// the next time of the trajectories is computed\n//we apply the discretisation of the grid to the traj positions\n//traj[it+1][dim] = traj[it][dim]+(*velocityField[dim])( round((traj[it][dim]-qmin[dim])/dq[dim]) )*dt;\nfractional = std::modf((traj[it][dim]-qmin[dim])/dq[dim], &whole);\nif(whole>=qDivs[dim]){whole=qDivs[dim]-2;}else if(whole<0){whole=0;}\ntraj[it+1][dim] = traj[it][dim]+( (1-fractional)*(*velocityField[dim])(whole)+fractional*(*velocityField[dim])(whole+1) )*dt;\n}\nfor(int dim=0; dim<dimNum; ++dim){\nprobabDataFile << abs2(psiNext[dim]->array()) << endl << endl<<endl;\n}\ntensorProduct = abs2(((*psiNext[1])*(psiNext[0]->transpose())).array());\n    for(int i=0; i<=qDivs[0]; i+=enoughStepq0){for(int j=0; j<=qDivs[1]; j+=enoughStepq1){\ntensorProdData << posq0[i] << \" \" << posq1[j] << \" \" << tensorProduct(j,i) << endl;\n}\ntensorProdData << endl;}\ntensorProdData << endl;\n//Output al file aki todas psi de una\n}//go to next time iteration\nEndTrajComput:\nfor(int it=0; it<=numIt; ++it){\nfor(int dim =0; dim<dimNum; ++dim){ trajDataFile << traj[it][dim] << \" \";\n}\ntrajDataFile <<\" 0\"<<endl;\n}\n }\nprobabDataFile.close();\ntrajDataFile.close();\ntensorProdData.close();\nofstream potentialToPlot;\n \ncout << \" Proceeding to prepare the Potential Energy Plot data...\" << endl;\npotentialToPlot.open(\"DATA_potentialToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\nfor(int it=0; it<=numIt; ++it){for(int i=0; i<=qDivs[0]; i+=enoughStepq0){for(int j=0; j<=qDivs[1]; j+=enoughStepq1){qAux[0]=posq0[i]; qAux[1]=posq1[j];potentialToPlot << qAux[0] << \" \" << qAux[1] << \" \" << V(qAux, tmin+it*dt)<< endl;}potentialToPlot<<endl;}potentialToPlot<<endl;}potentialToPlot.close();\nreturn 0;\n}\n";
    writtenFile.close();
    return 0;
    

    }else if(option==11){ //XO ImTimeEvol NOT PARALLEL ANIMATION YES TENSOR PRODUCT
        
    writtenFile.open("CODE_simulator_nD_XO_ZERO_CN_tDEP_ImTimeEv.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }
    writtenFile << "//SCHRODINGER EQUATION SOLVER nD - XO ALGORITHM ZERO-th ORDER APROXIMATION of G, J: IMAGINARY TIME EVOLUTION\n// Each single particle SE is solved with the CRANCK NICOLSON METHOD using Absorbing Boundary Conditions (ABCs)\n// SUPPORTS TIME DEPENDENT POTENTIALS\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <cmath>\n#include <random>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\nconst double PI = 3.141592653589793238463;\nconst double EULER=2.718281828459045;\n// We DEFINE the INITIAL WAVEPACKET\ncdouble psi0(double *q){\n" << argVec[2] <<";\n}\n//We define the Potential Energy Field in time\ndouble V(double* q, double t){\n" << argVec[3] <<";\n}\n\n//We set the time dependant susbtitute for i for the imaginary time evolution\ncdouble substituteFor_i(double t){" <<argVec[14]<< ";}\n\n//MAIN----------------------------------------------------------------\nint main(){\n\n//STUFF DECLARATION--------------------------------------------------------------------\nint dimNum = "<< argVec[1] <<";\nint numTrajs=" << argVec[11] <<";\ndouble* qAux=new double[dimNum];\ndouble hbar =" << argVec[13] <<";\ndouble m[] ={" << argVec[4] <<"};\ndouble normSqrd;\n//We define the spatial grid\nint qDivs[] ={" << argVec[5]<< "};\ndouble qmin[] ={"<<argVec[6]<<"};\ndouble qmax[] ={"<<argVec[7]<<"};\ndouble* dq=new double[dimNum];\nfor(int i=0; i<dimNum; ++i) {dq[i]=(qmax[i]-qmin[i])/qDivs[i];}\n// We define the time grid\ndouble tmin=0.0;\ndouble dt="<< argVec[8]<<";\nint numIt="<< argVec[9] <<";\n//we define the trajectory matrix\ndouble** traj=new double*[numIt+1];\nfor (int i=0; i<=numIt; ++i){ traj[i]= new double[dimNum];} // the trajectory is saved in an array of numIt arrays of dimNum doubles\n// each of the numIt arrays contains the value for the trajectory in each of the coordinates at that iteration\n//We declare the array of n initial SPCWF, the auxiliar U2*psi vectors and the Conditional connjugate and velocityField vectors. We also declare the probability density function for the renormalisation\nVectorXcd** psiNext = new VectorXcd*[dimNum];\nVectorXcd** conjPsi = new VectorXcd*[dimNum];\nVectorXcd** auxComplexVector = new VectorXcd*[dimNum]; \nArrayXd** probDensity = new ArrayXd*[dimNum]; //each entry points to a full SPCW\nVectorXcd** U2psi= new VectorXcd*[dimNum];\nArrayXd** velocityField = new ArrayXd*[dimNum];\n//We declare the auxiliar position vectors for obtaining pondered initial positions form the multidimensional WF\nint gridPointsIfNotCond=1;\nfor(int i=0; i<dimNum; ++i){\ngridPointsIfNotCond*=(qDivs[i]+1);\n}\ndouble** positArrays=new double*[gridPointsIfNotCond];\nstd::function<void(int,long int*, double*)> recursiveFillPosit;\nrecursiveFillPosit = [&](int k, long int* s, double* qAux){\nif(k==0){\nfor(int i=0; i<=qDivs[0]; ++i){\nqAux[0] = qmin[0] + i*dq[0];\npositArrays[*s]=new double[dimNum];\nmemcpy ( positArrays[*s], qAux, sizeof(double)*dimNum );\n(*s)+=1;\n}\n}else{\nfor(int i=0; i<=qDivs[k]; ++i){\nqAux[k] = qmin[k] + i*dq[k];\nrecursiveFillPosit(k-1, s, qAux);\n}\n}\n};\nlong int s=0;\nrecursiveFillPosit(dimNum-1, &s, qAux);\ndouble* probabDensity= new double[gridPointsIfNotCond];\nstd::function<void(int,long int*, double*, cdouble (*psi0)(double*))> recursiveGenerateMultidimProbab;\nrecursiveGenerateMultidimProbab = [&](int k, long int*s, double* qAux, cdouble (*psi0)(double*)){\nif(k==0){\nfor(int i=0; i<=qDivs[0]; ++i){\nqAux[0] = qmin[0] + i*dq[0];\nprobabDensity[*s]=norm(psi0(qAux));\n(*s)+=1;\n}\n}else{\nfor(int i=0; i<=qDivs[k]; ++i){\nqAux[k] = qmin[k] + i*dq[k];\nrecursiveGenerateMultidimProbab(k-1, s, qAux, psi0);\n}\n}\n};\ns=0;\nrecursiveGenerateMultidimProbab(dimNum-1, &s, qAux, psi0);\n// thus we have that probabDensity in each index contains the proability associated to the space point\n// registered in the same index but in the array positArrays (as a point in R^n)\n//now we build the random number generator according to this distribution\nstd::default_random_engine generator;\nstd::discrete_distribution<int> distribution (probabDensity,probabDensity+gridPointsIfNotCond-1);\nint randomIndex;\n// We build the templates for two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble>** U1= new SparseMatrix<cdouble>*[dimNum]; // one operator per considered dimension\nSparseMatrix<cdouble>** U2= new SparseMatrix<cdouble>*[dimNum]; // one operator per considered dimension\ncdouble a;\nSparseLU<SparseMatrix<cdouble>> LUsolver;\n//parameters for trajectory evolution\ndouble whole, fractional;\n//A matrix to save the tensor product of the two SPCWF in the case of two dimensional systems and a position vector pair for an easier posterior plot\nMatrixXd tensorProduct(qDivs[1]+1, qDivs[0]+1);\nofstream tensorProdData;\ntensorProdData.open(\"DATA_tensorProduct_nD_XO_ZERO_CN_ABC_tDEP.txt\");\nint enoughStepq0=qDivs[0]*"<< argVec[12]<< ";\nint enoughStepq1=qDivs[1]*"<< argVec[12]<< ";\ndouble* posq0=new double[qDivs[0]+1];\ndouble* posq1=new double[qDivs[1]+1];\nfor(int i=0; i<=qDivs[0]; i+=enoughStepq0){\nposq0[i]=qmin[0]+i*dq[0];}for(int j=0; j<=qDivs[1]; j+=enoughStepq1){ posq1[j]=qmin[1]+j*dq[1];}\n//we declare and build the basis of the operators and the vectors to use\nfor(int i=0; i<dimNum; ++i){\npsiNext[i]= new VectorXcd(qDivs[i]+1);\nconjPsi[i]= new VectorXcd(qDivs[i]+1);\nauxComplexVector[i]= new VectorXcd(qDivs[i]+1);\nprobDensity[i]= new ArrayXd(qDivs[i]+1);\nU2psi[i]= new VectorXcd(qDivs[i]+1);\nvelocityField[i] = new ArrayXd(qDivs[i]+1);\n\nU1[i] = new SparseMatrix<cdouble>(qDivs[i]+1, qDivs[i]+1);\nU1[i]->reserve(VectorXi::Constant(qDivs[i]+1,3));\nU2[i] = new SparseMatrix<cdouble>(qDivs[i]+1, qDivs[i]+1);\nU2[i]->reserve(VectorXi::Constant(qDivs[i]+1,3));\na=substituteFor_i(tmin)*dt*hbar/(4*m[i]*dq[i]*dq[i]);\nfor(int j=1;j<qDivs[i];++j){\nU1[i]->insert(j,j+1)= -a;\nU1[i]->insert(j,j-1)= -a;\nU1[i]->insert(j,j)= 1.0+substituteFor_i(tmin)*1.0;\n\nU2[i]->insert(j,j+1)= a;\nU2[i]->insert(j,j-1)= a;\nU2[i]->insert(j,j)= 1.0-substituteFor_i(tmin)*1.0;\n}\nU1[i]->insert(0,0)= substituteFor_i(tmin)*1.0;\nU2[i]->insert(0,0)= substituteFor_i(tmin)*1.0;\nU1[i]->insert(qDivs[i],qDivs[i])= substituteFor_i(tmin)*1.0;\nU1[i]->insert(0,1)= -a;\nU1[i]->insert(qDivs[i],qDivs[i]-1)= -a;\nU1[i]->makeCompressed();\n\nU2[i]->insert(qDivs[i],qDivs[i])= substituteFor_i(tmin)*1.0;\nU2[i]->insert(0,1)= a;\nU2[i]->insert(qDivs[i],qDivs[i]-1)= a;\nU2[i]->makeCompressed();\n}\n//output files prepared\nofstream probabDataFile, trajDataFile;\n//psiDataFile.open(\"DATA_rawSimulationData_nD_XO_ZERO_CN_ABC_tDEP.txt\");\nprobabDataFile.open(\"DATA_probabilityToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\ntrajDataFile.open(\"DATA_trajectoriesToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\n//psiDataFile << std::setprecision(17);\nprobabDataFile << std::setprecision(17);\ntrajDataFile << std::setprecision(17);\n/*probabDataFile << dimNum << \" \" << numIt << \" \";\nfor(int dim=0; dim< dimNum; ++dim){ probabDataFile << qDivs[dim] << \" \";} for(int dim=0; dim< dimNum; ++dim){ probabDataFile << qmin[dim] << \" \";}\nfor(int dim=0; dim< dimNum; ++dim){ probabDataFile << qmax[dim] << \" \";}\nprobabDataFile<< \" (dimensionNumber, time iterations, SpatialDivisions in each dimension, qmin in each dimension, qmax in each dimension) XO ZERO CN ABCs \" << endl;*/\n//BEGINING OF THE PROPER ALGORITHM-------------------------------------------------------------------\n// everything is iterated as many times as trajectories we want to evolve using the algorithm\nfor(int trajNum=0; trajNum<numTrajs; ++trajNum){\n//we choose the initial coordinates of the trajectory of this iteration randomly pondered according to the initial WF\nrandomIndex=distribution(generator);\nfor(int i=0; i<dimNum; i++){\ntraj[0][i] = positArrays[randomIndex][i];\n}\nfor(int i=0; i<dimNum; ++i){ // coordinate number\nfor(int j=0; j<dimNum; ++j){ qAux[j]=traj[0][j];} //evaluation of the qb[t0]\nfor(int j=0; j<=qDivs[i]; ++j){\nqAux[i]=qmin[i]+j*dq[i];\n// We build the the n initial SPCWFs - Single Particle Conditional Wave Functions\n(*psiNext[i])(j)=psi0(qAux);\n}\n}\n//TIME ITERATIONS--------------------------------------------------\nfor(int it=0; it<numIt; ++it){\nfor(int dim=0; dim<dimNum; ++dim){\nfor(int j=0; j<dimNum; ++j){ qAux[j]=traj[it][j];} //REVISAR IT A BER HOLAN BADAN!!!!! //evaluation of the b\n//we redefine the propagator matrices for the new time (the potential is time dependent)\na=substituteFor_i(tmin+dt*it)*dt*hbar/(4*m[dim]*dq[dim]*dq[dim]);\nfor(int i=1;i<qDivs[dim];++i){\nqAux[dim]=qmin[dim]+i*dq[dim];\nU1[dim]->coeffRef(i,i)= 1.0+substituteFor_i(tmin+dt*it)*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\n\nU2[dim]->coeffRef(i,i)= 1.0-substituteFor_i(tmin+dt*it)*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\nU1[dim]->coeffRef(i,i+1)= -a;\nU1[dim]->coeffRef(i,i-1)= -a;\n\nU2[dim]->coeffRef(i,i+1)= a;\nU2[dim]->coeffRef(i,i-1)= a;\n\n}\n\nU1[dim]->coeffRef(0,0)= 1.0+substituteFor_i(tmin+dt*it)*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\nU2[dim]->coeffRef(0,0)= 1.0-substituteFor_i(tmin+dt*it)*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\nU1[dim]->coeffRef(qDivs[dim],qDivs[dim])= 1.0+substituteFor_i(tmin+dt*it)*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\nU1[dim]->coeffRef(0,1)= -a;\nU1[dim]->coeffRef(qDivs[dim],qDivs[dim]-1)= -a;\n\nU2[dim]->coeffRef(qDivs[dim],qDivs[dim])= 1.0-substituteFor_i(tmin+dt*it)*dt*(hbar*hbar/(m[dim]*dq[dim]*dq[dim])+V(qAux,tmin+dt*it))/((cdouble)2*hbar);\nU2[dim]->coeffRef(0,1)= a;\nU2[dim]->coeffRef(qDivs[dim],qDivs[dim]-1)= a;\n\nU1[dim]->makeCompressed();\n\nU2[dim]->makeCompressed();\nLUsolver.compute(*U1[dim]);\nif(LUsolver.info()!=Success) {cout << \"LU decomposition FAILED!\" << endl << LUsolver.lastErrorMessage()<<endl<<endl;goto EndTrajComput; }\n*U2psi[dim]= (*U2[dim])*(*psiNext[dim]);\n*psiNext[dim] = LUsolver.solve(*U2psi[dim]);\n} //End evolving a time unit the SPCWFs\n//COMPUTE NEXT TRAJS--------------------------------------------------------------------------------------\n// we extract the conditional phase of each of the SPCWF, make it a continous curve and obtain the conditional velocity field\nfor(int dim=0; dim<dimNum; ++dim){\n\n//The SPCWF is first of all renormalised whatever that means:\n//the re-normalisation must be done after each imaginary dissipative time\n//well first calculate the squared norm of the wavevector and then divide it by the sqrt of it\n*probDensity[dim] = abs2(psiNext[dim]->array());\nnormSqrd=0.5*((*probDensity[dim])(0) + (*probDensity[dim])(qDivs[dim]));\n for(int ix=0; ix<=qDivs[dim]; ++ix){normSqrd+=(*probDensity[dim])(qDivs[dim]);}\nnormSqrd*=dq[dim];\n*psiNext[dim] = (*psiNext[dim])/sqrt(normSqrd);\n //Well now get the inverse psi for the velocity field computation\n\n(*conjPsi[dim]) = conj(psiNext[dim]->array());\n// psi_qi^-1* diff(psi_qi,qi) is computed\n//the borders are get with an Euler difference o(dq) and the immediate divisions with a central difference o(dq^2)\n(*auxComplexVector[dim])(0)=(*conjPsi[dim])(0)*((*psiNext[dim])(1)-(*psiNext[dim])(0))/(dq[dim]*(*probDensity[dim])(0));\n(*auxComplexVector[dim])(1)=(*conjPsi[dim])(1)*((*psiNext[dim])(2)-(*psiNext[dim])(0))/(2.0*dq[dim]*(*probDensity[dim])(1));\n//the rest of points are got with a o(dq^4) difference\nfor(int i=2; i<(qDivs[dim]-2); i++){\n(*auxComplexVector[dim])(i)=(*conjPsi[dim])(i)*(-(*psiNext[dim])(i+2)+8.0*(*psiNext[dim])(i+1)-8.0*(*psiNext[dim])(i-1)+(*psiNext[dim])(i-2))/(12.0*dq[dim]*(*probDensity[dim])(i));\n}\n(*auxComplexVector[dim])(qDivs[dim]-1)=(*conjPsi[dim])(qDivs[dim]-1)*((*psiNext[dim])(qDivs[dim])-(*psiNext[dim])(qDivs[dim]-2))/(2.0*dq[dim]*(*probDensity[dim])(qDivs[dim]-1));\n(*auxComplexVector[dim])(qDivs[dim])=(*conjPsi[dim])(qDivs[dim])*((*psiNext[dim])(qDivs[dim])-(*psiNext[dim])(qDivs[dim]-1))/(dq[dim]*(*probDensity[dim])(qDivs[dim]));\n// imaginary part is extracted and Jk obtained\n*velocityField[dim] = (hbar/m[dim])*imag(auxComplexVector[dim]->array());\n// the next time of the trajectories is computed\n//we apply the discretisation of the grid to the traj positions\n//traj[it+1][dim] = traj[it][dim]+(*velocityField[dim])( round((traj[it][dim]-qmin[dim])/dq[dim]) )*dt;\nfractional = std::modf((traj[it][dim]-qmin[dim])/dq[dim], &whole);\nif(whole>=qDivs[dim]){whole=qDivs[dim]-2;}else if(whole<0){whole=0;}\ntraj[it+1][dim] = traj[it][dim]+( (1-fractional)*(*velocityField[dim])(whole)+fractional*(*velocityField[dim])(whole+1) )*dt;\n}\nfor(int dim=0; dim<dimNum; ++dim){\nprobabDataFile << abs2(psiNext[dim]->array()) << endl << endl<<endl;\n}\ntensorProduct = abs2(((*psiNext[1])*(psiNext[0]->transpose())).array());\n    for(int i=0; i<=qDivs[0]; i+=enoughStepq0){for(int j=0; j<=qDivs[1]; j+=enoughStepq1){\ntensorProdData << posq0[i] << \" \" << posq1[j] << \" \" << tensorProduct(j,i) << endl;\n}\ntensorProdData << endl;}\ntensorProdData << endl;\n//Output al file aki todas psi de una\n}//go to next time iteration\nEndTrajComput:\nfor(int it=0; it<=numIt; ++it){\nfor(int dim =0; dim<dimNum; ++dim){ trajDataFile << traj[it][dim] << \" \";\n}\ntrajDataFile <<\" 0\"<<endl;\n}\n }\nprobabDataFile.close();\ntrajDataFile.close();\ntensorProdData.close();\nofstream potentialToPlot;\n \ncout << \" Proceeding to prepare the Potential Energy Plot data...\" << endl;\npotentialToPlot.open(\"DATA_potentialToPlot_nD_XO_ZERO_CN_ABC_tDEP.txt\");\nfor(int it=0; it<=numIt; ++it){for(int i=0; i<=qDivs[0]; i+=enoughStepq0){for(int j=0; j<=qDivs[1]; j+=enoughStepq1){qAux[0]=posq0[i]; qAux[1]=posq1[j];potentialToPlot << qAux[0] << \" \" << qAux[1] << \" \" << V(qAux, tmin+it*dt)<< endl;}potentialToPlot<<endl;}potentialToPlot<<endl;}potentialToPlot.close();\nreturn 0;\n}\n";
    writtenFile.close();
    return 0;
    }
}
    
